#
# Run-time Yocto platform environment. This file should be sourced.
#

# Make sure path is correctly set.
export PATH=$PATH:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin

# Set some important global variables.
SWI_OK=0
SWI_ERR=1
SWI_TRUE=1
SWI_FALSE=0

@if !mdm9x15
# For security authentiate result
SWI_NONE_SECU=2
SWI_AUTH_PASS=3
SWI_AUTH_FAIL=4

@endif
# Mount point for flash partition used by Legato and UFS.
FLASH_MOUNTPOINT=/mnt/flash

# smack mount point
SMACK_MOUNTPOINT=/mnt/smack

# Mount point for legato flash partition
FLASH_MOUNTPOINT_LEGATO=/mnt/legato

# The name of the MTD partition where legato is installed
@if mdm9x15
LEGATO_MTDEV_NAME=user0
@else
LEGATO_MTDEV_NAME=lefwkro
@endif

# UFS root
UFS_ROOT=${FLASH_MOUNTPOINT}/ufs

# The name of MTD partition where UFS RW space is located.
# This is also MTD partition where various user data is
# stored.
@if mdm9x15
UFS_MTDEV_NAME=user1
USER_MTDEV_NAME=user1
@else
UFS_MTDEV_NAME=userapp
USER_MTDEV_NAME=userapp
@endif

# The name of the partition where userrw FS is mounted.
@if mdm9x15
USERRW_MTDEV_NAME=user2
@else
USERRW_MTDEV_NAME=swirw
@endif

# Mount point for USERRW_MTDEV_NAME device.
USERRW_MTDEV_MOUNTPOINT=/mnt/userrw

@if mdm9x15
# Root file system UBI device number. This is not mtd device
# number.
UBI_ROOTFS_DEVNUM=0

@endif
# Scratch UBI volume name. The name must match one of the volume
# names in ubinize.cfg file.
UBI_SCRATCH_VOLNAME=scratch

@if mdm9x15
# UBI device number scratch volume is located on. In case it's
# needed, there is also partition number available.
UBI_SCRATCH_DEVNUM=${UBI_ROOTFS_DEVNUM}
UBI_SCRATCH_VOLNUM=1
@else
# UBI device number scratch volume is located on.
UBI_SCRATCH_DEVNUM=0
@endif

# If USER0 partition (or part of it) is mounted as UBI partition
# type (UBIFS, SQUASHFS-on-top-of-ubi, etc.), this is the
# device number which should be used.
@if mdm9x15
UBI_USER0_DEVNUM=1
@else
UBI_USER0_DEVNUM=2
@endif

# If Legato is wrapped in squashfs partition, it would be located
# on UBI partition 0.
UBI_USER0_LEGATO_VOLNUM=0

# If USER1 partition (or part of it) is mounted as UBI partition
# type (UBIFS, SQUASHFS-on-top-of-ubi, etc.), this is the
# device number which should be used.
@if mdm9x15
UBI_USER1_DEVNUM=2
@else
UBI_USER1_DEVNUM=3
@endif
UBI_USER1_VOLNUM=0
@if mdm9x15
UBI_USER1_VOLNAME=user1_vol0
@else
UBI_USER1_VOLNAME=userapp_vol0

# If USERRW partition (or part of it) is mounted as UBI partition
# type (UBIFS, SQUASHFS-on-top-of-ubi, etc.), this is the
# device number which should be used.
UBI_USERRW_DEVNUM=4
UBI_USERRW_VOLNUM=0
UBI_USERRW_VOLNAME=swirw_vol0

# ************************************************************
# Dm-verity partition contain raw data, hash bin and root hash.
# For security version need two more UBI volumes for signature
# root hash and cert chain. Each of these data will store in
# it's own UBI volumes position (hard code).
UBI_HASH_VOLNUM=1
UBI_RHASH_VOLNUM=2
UBI_SRH_VOLNUM=3
UBI_CERT_VOLNUM=4

# DM verity with security version should hard code the tatol number
# of UBI volumes for more security
DM_SECU_UBI_VOL_COUNT=5

# DM verity need mini number of UBI volumes
DM_MIN_UBI_VOL_COUNT=3

# Dm-verity for legato partition nod name
DM_LGT_NOD_NAME=lgt

# ************************************************************
@endif

# Size of /dev directory
DEVDIR_SIZE=262144

# UNIONFS type
@if mdm9x15
UFS_T=aufs
@else
UFS_T=overlay
@endif

# Name of this executable.
this_e=$( /usr/bin/basename $0 )

#
# Helper functions
#

# Logger. Call it as:
#    swi_log "This is the system log."
swi_log()
{
    echo "${this_e}: $1" | tee /dev/console | logger
}

# function to get UART service
uart_get_srv()
{
    # UART Service type
    unset UART1_SERVICE UART2_SERVICE
    unset UART1_DEVICE UART2_DEVICE

    local UART_CONFIG_FILE=config

    local UART1_CONFIG_1_DIR=/sys/devices/platform/msm_serial_hs.0
    local UART1_CONFIG_1_DEV=/dev/ttyHS0

    local UART1_CONFIG_2_DIR=/sys/devices/platform/msm_serial_hsl.0
    local UART1_CONFIG_2_DEV=/dev/ttyHSL0

    local UART2_CONFIG_DIR=/sys/devices/platform/msm_serial_hsl.1
    local UART2_CONFIG_DEV=/dev/ttyHSL1

    if [ -d ${UART1_CONFIG_1_DIR} ] && [ -f ${UART1_CONFIG_1_DIR}/${UART_CONFIG_FILE} ]; then
        UART1_SERVICE=$( cat ${UART1_CONFIG_1_DIR}/${UART_CONFIG_FILE} )
        if [ "x$UART1_SERVICE" != "xUNAVAILABLE" ]; then
            UART1_DEVICE=$UART1_CONFIG_1_DEV
        fi
    fi

    if [ -z "$UART1_DEVICE" ] && \
       [ -d ${UART1_CONFIG_2_DIR} ] && [ -f ${UART1_CONFIG_2_DIR}/${UART_CONFIG_FILE} ]; then
        UART1_SERVICE=$( cat ${UART1_CONFIG_2_DIR}/${UART_CONFIG_FILE} )
        UART1_DEVICE=$UART1_CONFIG_2_DEV
    fi

    if [ -d ${UART2_CONFIG_DIR} ] && [ -f ${UART2_CONFIG_DIR}/${UART_CONFIG_FILE} ]; then
        UART2_SERVICE=$( cat ${UART2_CONFIG_DIR}/${UART_CONFIG_FILE} )
        UART2_DEVICE=$UART2_CONFIG_DEV
    fi

    return 0
}

