/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
 
  $Id: hdrcnv.cpp,v 1.3 2010/11/03 21:02:55 bdu Exp $
  
  GENERAL DESCRIPTION
  Every image stored in the flash should have the same Core Wireless Engine
  compliant header.
  This tool permits to update or create this header.

    
  EXTERNALIZED FUNCTIONS
 
 
  Copyright (C) 2008 Sierra Wireless Inc. All rights reserved.
  ====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>

using namespace std;

static const char toolVersion[] = "3.00" ;


#define HEADER_SIZE                     0x90
#define HEADER_OFFSET                   0x100
#define HEADER_CRC_OFFSET               0x00
#define HEADER_REVISION_OFFSET          0x04
#define GOOD_LABEL_OFFSET               0x08        //-- Offsets in Header
#define IMAGE_ID_OFFSET                 0x0C
#define PRODUCT_TYPE_OFFSET             0x10
#define IMAGE_SIZE_OFFSET               0x14
#define CRC32_OFFSET                    0x18
#define VERSION_OFFSET                  0x1C
#define RELEASE_DATE_OFFSET             0x70
#define BACKWARD_COMPATIBILITY_OFFSET   0x78
#define HEADER_RESERVED_OFFSET          0x7C
#define STORAGE_ADDRESS_OFFSET          0x80
#define PROGRAM_RELOCATION_OFFSET       0x84
#define ENTRY_POINT_OFFSET              0x88
#define APPLICATION_SIGNATURE_OFFSET    0x8C

#define BCAPPSIGN                       0x00000001 //- Default appl signature

#define VERSION_SIZE                    84



#if 1
#define HEADER_REVISION                 3
#define IMAGE_ID                        "BOOT"
#define IMAGE_ID_LEN                    4
#define PRODUCT_TYPE                    "A875"
#define PRODUCT_TYPE_LEN                4
#endif

//--
//-- IEEE-802.3 32bit CRC
//--

#define START_CRC32         0xFFFFFFFF      //-- CRC initialised to all 1s



//-- This table was generated by the "crctable" program
static const unsigned int crc32table[256] =
{
  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,     // 0x00  
  0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,     // 0x04  
  0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,     // 0x08  
  0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,     // 0x0C  
  0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,     // 0x10  
  0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,     // 0x14  
  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,     // 0x18  
  0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,     // 0x1C  
  0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,     // 0x20  
  0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,     // 0x24  
  0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,     // 0x28  
  0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,     // 0x2C  
  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,     // 0x30  
  0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,     // 0x34  
  0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,     // 0x38  
  0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,     // 0x3C  
  0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,     // 0x40  
  0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,     // 0x44  
  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,     // 0x48  
  0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,     // 0x4C  
  0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,     // 0x50  
  0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,     // 0x54  
  0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,     // 0x58  
  0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,     // 0x5C  
  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,     // 0x60  
  0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,     // 0x64  
  0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,     // 0x68  
  0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,     // 0x6C  
  0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,     // 0x70  
  0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,     // 0x74  
  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,     // 0x78  
  0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,     // 0x7C  
  0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,     // 0x80  
  0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,     // 0x84  
  0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,     // 0x88  
  0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,     // 0x8C  
  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,     // 0x90  
  0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,     // 0x94  
  0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,     // 0x98  
  0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,     // 0x9C  
  0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,     // 0xA0  
  0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,     // 0xA4  
  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,     // 0xA8  
  0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,     // 0xAC  
  0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,     // 0xB0  
  0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,     // 0xB4  
  0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,     // 0xB8  
  0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,     // 0xBC  
  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,     // 0xC0  
  0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,     // 0xC4  
  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,     // 0xC8  
  0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,     // 0xCC  
  0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,     // 0xD0  
  0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,     // 0xD4  
  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,     // 0xD8  
  0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,     // 0xDC  
  0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,     // 0xE0  
  0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,     // 0xE4  
  0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,     // 0xE8  
  0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,     // 0xEC  
  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,     // 0xF0  
  0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,     // 0xF4  
  0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,     // 0xF8  
  0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D      // 0xFC  
};

/*
 * provide strncpy for unsigned char as destination, to get rid of warnings
 */
static char * strncpy( unsigned char *dst, const char * src, size_t cnt )
{
  return strncpy( (char *)dst, src, cnt );
}

//----------------------------------------------------------------------------

bool
FileExist(char *file)
{
  ifstream inFile( file, ios::binary | ios::in ) ;
  return inFile.is_open();
}


//----------------------------------------------------------------------------


unsigned int 
Crc32(unsigned char *address, unsigned int size, unsigned int crc)
{
  for (; size > 0 ; size--)
  {
    //-- byte loop */
    crc = (((crc >> 8) & 0x00FFFFFF) ^ crc32table[(crc ^ *address++) & 0x000000FF]);
  }
  return crc ;
}


//----------------------------------------------------------------------------

//--
//-- Compute the checksum of the file and return its code size (without the header)
//--

unsigned int
ComputeCRC32(char *fileName, unsigned int *crc32p, bool writeback)
{
  unsigned char   buffer[20500] ;
  unsigned int    codeSize ;
  int             i ;

  ifstream inFile(fileName, ios::binary | ios::in) ;

  if(writeback == true)
  {
    // CWE header need write back, that means the begining of 
    // the image is a dummy CWE header, skip header to the start of code
    inFile.read((char *)buffer, HEADER_OFFSET + HEADER_SIZE) ;      //-- Read the entire header
  }
  codeSize = 0 ;
  *crc32p = START_CRC32 ;

  while (inFile.eof() == 0)
  {
    inFile.read( (char *)buffer, sizeof(buffer) );
    i = inFile.gcount(); 
    *crc32p = Crc32(buffer, i, *crc32p) ;
    codeSize+=i ;
  }

  inFile.close() ;
  return codeSize ;
}


//----------------------------------------------------------------------------


unsigned long
StrToULongHex(char *str)
{
  unsigned long   res ;
  int             i ;

  res = 0 ;
  i = 0 ;

  while (str[i] != '\0')
  {
    if ((str[i] >= '0') && (str[i] <= '9'))
    {
      res = (res * 16) + str[i] - '0' ;
      i++ ;
    }
    else if ((str[i] >= 'a') && (str[i] <= 'f'))
    {
      res = (res * 16) + (str[i] - 'a') + 10 ;
      i++ ;
    }
    else if ((str[i] >= 'A') && (str[i] <= 'F'))
    {
      res = (res * 16) + (str[i] - 'A') + 10 ;
      i++ ;
    }
    else
    {
      return 0 ;
    }
  }
  return res ;
}


//----------------------------------------------------------------------------


char *
UpperCase(char *str)
{
  for (unsigned int i = 0 ; i < strlen(str) ; i++)
  {
    str[i] = toupper(str[i]) ;
  }
  return str;
}



//----------------------------------------------------------------------------

/*
 * Name:  writeuint32nbo - write uint32 in network byte order
 *
 * Purpose: Convert an unsiged int field (32 bits) into network byte order, no matter
 *      this field is represented in Little or Big Endian
 *
 * Params:  value - value of the 32-bit field
 *      bufp - pointer to the buffer where the result is to be put to
 *
 * Return:  
 *        
 * Note:   
 *
 */

void writeuint32nbo(unsigned int value, unsigned char *bufp)
{
  *bufp = (value >> 24);
  bufp++;
  *bufp = (value >> 16);
  bufp++;
  *bufp = (value >> 8);
  bufp++;
  *bufp = value;
}


//----------------------------------------------------------------------------

/*
 * Name:  writeuint32le - write uint32 in little endian order
 *
 * Purpose: Convert an unsiged int field (32 bits) into little endian byte order
 *
 * Params:  value - value of the 32-bit field
 *      bufp - pointer to the buffer where the result is to be put to
 *
 * Return:  
 *        
 * Note:   
 *
 */

void writeuint32le(unsigned int value, unsigned char *bufp)
{
  *bufp = value;
  bufp++;
  *bufp = (value >> 8);
  bufp++;
  *bufp = (value >> 16);
  bufp++;
  *bufp = (value >> 24);
}


int main(int argc, char *argv[])
{
  ifstream        inImgFile ; //-- Input application image file
  ofstream        outImgFile ; //-- Ouput application image file
  ifstream        inPsbFile ; //-- Input Product Specific Buffer file
  ofstream        outHdrFile ; //-- Output CWE header file
  char            bufferPsb[HEADER_OFFSET] = {0};
  unsigned char   buffer[HEADER_SIZE] = {0};
  char            str[1024] ;
  char            inputPsbFileName[256] ;
  char            outputHdrFileName[256] ;
  char            outputimgFileName[256] ;
  unsigned int    crc32 ;
  unsigned int    headerCrc ;
  unsigned int    codeSize ;
  int             nbArg ;
  bool            result ;
  bool            inputPsbFile = false ;
  bool            outputHdrFile = false ;
  bool            imageType = false ;
  bool            productType = false ;
  bool            versionTime = false ;
  bool            releaseDate = false ;
  bool            backwardComp = false ;
  bool            reservedA = false ;
  bool            reservedB = false ;
  bool            loadAddr = false ;
  bool            entryPoint = false ;
  bool            signature = false ;
  bool            writeback = false;


  if (argc < 2)
  {
    cout << endl << endl ;
    cout << "CWE header generator, version " << toolVersion << endl ;
    cout << "Copyright (C) 2012 Sierra Wireless, Inc." << endl << endl ;
    cout << "Source code at $Source: https://carmd-app30.sierrawireless.local/svn/tools/hdrcnv/hdrcnv.cpp,v $" << endl << endl ;
    cout << "-----------------------------------------" << endl ;
    cout << "USAGE:" << endl ;
    cout << "   hdrcnv <input image file>" << endl ; 
    cout << "          -PSB input PSB file" << endl ;
    cout << "          -OH  output CWE header file" << endl ; 
    cout << "          -IT  Image Type                  -- 4 bytes" << endl ;
    cout << "          -PT  Product Type                -- 4 bytes" << endl ;
    cout << "          -V   Version                     -- 84 char max" << endl ;
    cout << "          -RD  Release Date (MM/DD/YY)     -- 8 bytes" << endl ;
    cout << "          -B   Backward Compatibility      -- Hex Value (8 char)" << endl ;
    cout << "          -RA  Reserved                    -- 4 bytes" << endl ;
    cout << "          -SA  Storage Address             -- Hex Value (8 char)" << endl ;
    cout << "          -PR  Program Relocation Address  -- Hex Value (8 char)" << endl ;
    cout << "          -EP  Entry Point                 -- Hex Value (8 char)" << endl ;
    cout << "          -S   Signature                   -- 4 bytes" << endl ;
    cout << "          -WB  dummy                       -- Write back CWE header" << endl ;
   cout << endl ;
    return -1 ;
  }

  //-- Make sure the application image file exist
  if (FileExist(argv[1]) != true)
  {
    cout << endl << "ERROR: Application file " << argv[1] << " does not exist" << endl ;
    return 0 ;
  }

  //-- Write Header Revision Number
  writeuint32nbo(HEADER_REVISION, (unsigned char *)(&buffer[HEADER_REVISION_OFFSET]));

  //-- Set the "GOOD" label (serial downloader will update this field based on CRC checking)
  buffer[GOOD_LABEL_OFFSET] = 0xff;
  buffer[GOOD_LABEL_OFFSET+1] = 0xff;
  buffer[GOOD_LABEL_OFFSET+2] = 0xff;
  buffer[GOOD_LABEL_OFFSET+3] = 0xff;

  //-- Write default Image Type
  strncpy(&buffer[IMAGE_ID_OFFSET], IMAGE_ID, IMAGE_ID_LEN);

  //-- Write default Product Type
  strncpy(&buffer[PRODUCT_TYPE_OFFSET], PRODUCT_TYPE, PRODUCT_TYPE_LEN);

  //-- Write default Application Signature
  writeuint32nbo(BCAPPSIGN, (unsigned char *)(&buffer[APPLICATION_SIGNATURE_OFFSET]));

  //-- Process the options
  if ((argc > 2) && ((argc - 2) % 2) == 0)
  {
    nbArg = 2 ;
    result = true ;
    while ((nbArg < argc) && (result == true))
    {
      if (strcmp(UpperCase(argv[nbArg]), "-PSB") == 0)            //-- Input PSB File
      {
        if (inputPsbFile == true)
        {
          //-- Already found argument
          cout << endl << "Input PSB File Already Specified" << endl ;
          result = false ;
        }
        else
        {
          inputPsbFile = true ;
          strncpy(inputPsbFileName, argv[nbArg + 1], sizeof(inputPsbFileName)) ;
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-OH") == 0)        //-- Output CWE Header File
      {
        if (outputHdrFile == true)
        {
          //-- Already found argument
          cout << endl << "Output CWE Header File Already Specified" << endl ;
          result = false ;
        }
        else
        {
          outputHdrFile = true ;
          strncpy(outputHdrFileName, argv[nbArg + 1], sizeof(outputHdrFileName)) ;
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-IT") == 0)        //-- Image Type
      {
        if (imageType == true)
        {
          //-- Already found argument
          cout << endl << "Image Type already found" << endl ;
          result = false ;
        }
        else
        {
          imageType = true ;
          if (strlen(argv[nbArg + 1]) != 4)
          {
            cout << endl << "Incorrect Image Type: " 
                 << UpperCase(argv[nbArg + 1]) << endl ;
            result = false ;
          }
          else
          {
            strncpy(&buffer[IMAGE_ID_OFFSET], UpperCase(argv[nbArg + 1]), 4) ;
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-PT") == 0)   //-- Product Type
      {
        if (productType == true)
        {
          //-- Already found argument
          cout << endl << "Product Type already found" << endl ;
          result = false ;
        }
        else
        {
          productType = true ;
          if (strlen(argv[nbArg + 1]) != 4)
          {
            cout << endl << "Incorrect Product Type: " 
                 << UpperCase(argv[nbArg + 1]) << endl ;
            result = false ;
          }
          else
          {
            strncpy(&buffer[PRODUCT_TYPE_OFFSET], UpperCase(argv[nbArg + 1]), 4) ;
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-V") == 0)    //-- Version/Time
      {
        if (versionTime == true)
        {
          //-- Already found argument
          cout << endl << "Version/Time already found" << endl ;
          result = false ;
        }
        else
        {
          versionTime = true ;
          memset(&buffer[VERSION_OFFSET], 0, VERSION_SIZE) ;
          if (strlen(argv[nbArg + 1]) >= VERSION_SIZE)
          {
            strncpy(&buffer[VERSION_OFFSET], argv[nbArg + 1], VERSION_SIZE) ;
            buffer[VERSION_OFFSET + VERSION_SIZE] = '\0' ;
          }
          else
          {
            strncpy(&buffer[VERSION_OFFSET], argv[nbArg + 1], VERSION_SIZE) ;
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-RD") == 0)   //-- Release Date
      {
        if (releaseDate == true)
        {
          //-- Already found argument
          cout << endl << "Release Date already found" << endl ;
          result = false ;
        }
        else
        {
          releaseDate = true ;
          if (strlen(argv[nbArg + 1]) != 8)
          {
            cout << endl << "Incorrect Release Date: " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            strncpy(&buffer[RELEASE_DATE_OFFSET], argv[nbArg + 1], 8) ;
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-B") == 0)    //-- Backward Compatibility
      {
        if (backwardComp == true)
        {
          //-- Already found argument
          cout << endl << "Backward Compatibility already found" << endl ;
          result = false ;
        }
        else
        {
          backwardComp = true ;
          if (strlen(argv[nbArg + 1]) != 8)
          {
            cout << endl << "Incorrect Backward Compatibility: " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            unsigned int tmpInt = StrToULongHex(argv[nbArg + 1]) ;
            if (tmpInt == 0)
            {
              cout << endl << "Incorrect Backward Compatibility: "
                   << argv[nbArg + 1] << endl ;
              result = false ;
            }
            else
            {
              unsigned char *ptr = (unsigned char *)&buffer[BACKWARD_COMPATIBILITY_OFFSET] ;
              writeuint32nbo(tmpInt, ptr);
            }
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-RA") == 0)   //-- Header Reserved
      {
        if (reservedA == true)
        {
          //-- Already found argument
          cout << endl << "Reserved already found" << endl ;
          result = false ;
        }
        else
        {
          reservedA = true ;
          if (strlen(argv[nbArg + 1]) != 4)
          {
            cout << endl << "Incorrect Reserved : " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            strncpy(&buffer[HEADER_RESERVED_OFFSET], UpperCase(argv[nbArg + 1]), 4) ;
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-SA") == 0)   //-- Storage Address
      {
        if (reservedB == true)
        {
          //-- Already found argument
          cout << endl << "Storage Address already found" << endl ;
          result = false ;
        }
        else
        {
          reservedB = true ;
          if ((strlen(argv[nbArg + 1]) > 8) || (strlen(argv[nbArg + 1]) == 0))
          {
            cout << endl << "Storage Address : " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            // allow the 0x notation
            if (toupper(*(argv[nbArg + 1] + 1)) == 'X')
            {
              argv[nbArg + 1] += 2;
            }

            unsigned int tmpInt = StrToULongHex(argv[nbArg + 1]) ;
            if (tmpInt == 0)
            {
              cout << endl << "Incorrect Storage Address: "
                   << argv[nbArg + 1] << endl ;
              result = false ;
            }
            else
            {
              unsigned char *ptr = (unsigned char *)&buffer[STORAGE_ADDRESS_OFFSET] ;
              if (HEADER_REVISION < 2)
              {
                writeuint32nbo(tmpInt, ptr);
              }
              else
              {
                writeuint32le(tmpInt, ptr);
              }
            }
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-PR") == 0)   //-- Program Relocation Address
      {
        if (loadAddr == true)
        {
          //-- Already found argument
          cout << endl << "Program Relocation Address already found" << endl ;
          result = false ;
        }
        else
        {
          loadAddr = true ;
          if ((strlen(argv[nbArg + 1]) > 8) || (strlen(argv[nbArg + 1]) == 0))
          {
            cout << endl << "Incorrect Program Relocation Address: " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            // allow the 0x notation
            if (toupper(*(argv[nbArg + 1] + 1)) == 'X')
            {
              argv[nbArg + 1] += 2;
            }

            unsigned int tmpInt = StrToULongHex(argv[nbArg + 1]) ;
            if (tmpInt == 0)
            {
              cout << endl << "Incorrect Program Relocation Address: "
                   << argv[nbArg + 1] << endl ;
              result = false ;
            }
            else
            {
              unsigned char *ptr = (unsigned char *)&buffer[PROGRAM_RELOCATION_OFFSET] ;
              if (HEADER_REVISION < 2)
              {
                writeuint32nbo(tmpInt, ptr);
              }
              else
              {
                writeuint32le(tmpInt, ptr);
              }
            }
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-EP") == 0)   //-- Entry Point
      {
        if (entryPoint == true)
        {
          //-- Already found argument
          cout << endl << "Entry Point already found" << endl ;
          result = false ;
        }
        else
        {
          entryPoint = true ;
          if ((strlen(argv[nbArg + 1]) > 8) || (strlen(argv[nbArg + 1]) == 0))
          {
            cout << endl << "Incorrect Entry Point: " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
            // allow the 0x notation
            if (toupper(*(argv[nbArg + 1] + 1)) == 'X')
            {
              argv[nbArg + 1] += 2;
            }

            unsigned int tmpInt = StrToULongHex(argv[nbArg + 1]) ;
            if (tmpInt == 0)
            {
              cout << endl << "Incorrect Load Address: "
                   << argv[nbArg + 1] << endl ;
              result = false ;
            }
            else
            {
              unsigned char *ptr = (unsigned char *)&buffer[ENTRY_POINT_OFFSET] ;
              if (HEADER_REVISION < 2)
              {
                writeuint32nbo(tmpInt, ptr);
              }
              else
              {
                writeuint32le(tmpInt, ptr);
              }
            }
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-S") == 0)    //-- Signature
      {
        if (signature == true)
        {
          //-- Already found argument
          cout << endl << "Signature already found" << endl ;
          result = false ;
        }
        else
        {
          signature = true ;
          if (strlen(argv[nbArg + 1]) != 4)
          {
            cout << endl << "Incorrect Signature: " 
                 << argv[nbArg + 1] << endl ;
            result = false ;
          }
          else
          {
//cul+
//                      strncpy(&buffer[APPLICATION_SIGNATURE_OFFSET], argv[nbArg + 1], 4) ;
            strncpy(str, argv[nbArg + 1], 4) ;
            long tmpInt = ((str[0] - '0') << 24) +
              ((str[1] - '0') << 16) +
              ((str[2] - '0') << 8) +
              str[3] - '0';
            writeuint32nbo(tmpInt, (unsigned char *)(&buffer[APPLICATION_SIGNATURE_OFFSET]));
//cul-
          }
        }
      }
      else if (strcmp(UpperCase(argv[nbArg]), "-WB") == 0)   //-- write back the CWE header to the input img
      {
        writeback = true;
      }
      nbArg += 2 ;
    }
  }
  if (result == false)
  {
    cout << endl ;
    cout << "There was an ERROR" << endl << endl ;
    return 0 ;
  }

  //-- Compute CRC of the application image
  codeSize = ComputeCRC32(argv[1], &crc32, writeback) ;

  //-- Write the application image size
  writeuint32nbo(codeSize, (unsigned char *)(&buffer[IMAGE_SIZE_OFFSET]));

  //-- Write the CRC32 of the application image
  writeuint32nbo(crc32, (unsigned char *)(&buffer[CRC32_OFFSET]));



  if (releaseDate == false)
  {
    struct tm * timeinfo;
    time_t    now;
      
    time( &now );
    timeinfo = localtime( &now );
      
    sprintf( str, "%02d/%02d/%02d", 
             timeinfo->tm_mon+1, timeinfo->tm_mday, timeinfo->tm_year%100 );
    strncpy(&buffer[RELEASE_DATE_OFFSET], str, 8) ;     //-- MM/DD/YY
  }

  if (inputPsbFile == true)
  {
    // Read Product Specific Buffer (PSB)
    inPsbFile.open(inputPsbFileName, ios::binary | ios::in) ;
    if (inPsbFile.is_open() == 0)
    {
      cout << endl << "ERROR: Cannot open PSB file " << inputPsbFileName << endl ;
      return 0 ;
    }
    inPsbFile.read(bufferPsb, HEADER_OFFSET);
    inPsbFile.close() ;
  }

  //-- Compute the header CRC32
  headerCrc = Crc32((unsigned char *)bufferPsb, HEADER_OFFSET, START_CRC32) ;

  //-- Write CRC of Product Specific Buffer
  writeuint32nbo(headerCrc, (unsigned char *)(&buffer[HEADER_CRC_OFFSET]));

  //-- If the output header file name was not specified, use the input image file name
  if (outputHdrFile == false)
  {
    strncpy(outputHdrFileName, argv[1], sizeof(outputHdrFileName) );
    strcat(outputHdrFileName, ".hdr") ;
  }

  //-- Delete the output header file if exist
  if (FileExist(outputHdrFileName) == true)
  {
    unlink( outputHdrFileName );
  }

  //-- Create the output header file
  outHdrFile.open(outputHdrFileName, ios::binary | ios::out) ;
  if (outHdrFile.is_open() == 0)
  {
    cout << endl << "ERROR: Cannot create output header file " << outputHdrFileName << endl ;
    return 0 ;
  }

  //-- Write Product Specific Buffer
  outHdrFile.write(bufferPsb, HEADER_OFFSET) ;

  //-- Write the rest of the CWE header
  outHdrFile.write((const char *)buffer, HEADER_SIZE) ;

  outHdrFile.close() ;

  // if CWE header need to be write back to the input image
  // -- there was a dummy header there
  if(writeback == true)
  {
    //-- Create the output header file
    inImgFile.open(argv[1], ios::binary | ios::in) ;
    strcpy(outputimgFileName, argv[1]);
    strcat(outputimgFileName, ".tmp");
    outImgFile.open(outputimgFileName, ios::binary | ios::out) ;
    if (inImgFile.is_open() == 0 || outImgFile.is_open() == 0)
    {
      cout << endl << "ERROR: Cannot write back header" << argv[1] << endl ;
      return 0 ;
    }
    //-- Write Product Specific Buffer
    outImgFile.write(bufferPsb, HEADER_OFFSET) ;
    //-- Write the rest of the CWE header
    outImgFile.write((char *)buffer, HEADER_SIZE) ;
    // start reading from the input image file
    inImgFile.read(str, HEADER_OFFSET + HEADER_SIZE) ;
    inImgFile.read(str, 2) ;
    while (inImgFile.eof() == 0)
    {
      outImgFile.write(str, 2) ;
      inImgFile.read(str, 2) ;
    }
    inImgFile.close() ;
    outImgFile.close() ;
    remove(argv[1]);
    rename(outputimgFileName, argv[1]);
  }

  cout << endl ;
  cout << "CWE Header Generator " << toolVersion << ". Copyright (C) 2012 Sierra Wireless, Inc." << endl ;
  cout << "  Output CWE Header File " << outputHdrFileName << endl ;
  cout.setf(ios::hex, ios::basefield) ;
  cout << "  Image size 0x" << codeSize << ", crc32 0x" << crc32 << endl ;
  cout << endl ;

  return 0 ;
}

/*
 * $Log: hdrcnv.cpp,v $
 * Revision 1.3  2010/11/03 21:02:55  bdu
 * Bug#26674
 * Minor update: don't force upper case on version string, increased CRC computing buffer
 *  size
 *
 * Revision 1.2  2008/12/11 22:38:12  bdu
 * bug#13629
 * Restored the -wb option from 8200 project
 *
 * Revision 1.1  2008/11/26 16:22:44  msafar
 * bug#13380
 * - compiles under Linux, Cygwin and MSVC
 * - makefile works in Cygwin and Linux environment (g++)
 *
 * Revision 1.1  2008/03/03 19:04:12  bdu
 * bug#10169
 * hdrcnv tool initial import
 *
 * Revision 1.1  2007/08/04 01:54:07  lwang
 * bug#8735
 * Initial checkin with M7200JSDCAADZD4120 stack
 *
 * Revision 1.2  2007/03/30 23:20:41  imorrison
 * bug#7143
 * Recompiled to use proper endianness for bcStorAddr, bcProgAddr, and
 * bcEntry. Changed to accept 0-8 chars for these parameters on the
 * command line.
 *
 * Revision 1.1  2007/01/06 03:27:17  lwang
 * bug#6960
 * Added M7200BSKCBADZD3050 stack
 *
 * Revision 1.1  2006/10/02 22:11:51  lwang
 * bug#6297
 * Port of sierra/tools directory
 *
 * Revision 1.2  2006/02/22 18:33:27  lwang
 * NAND flash firmware download
 *
 * Revision 1.1  2006/02/03 17:51:14  lwang
 * Add AMSS 6280 Rel 2.0.10 Thin UI
 *
 * Revision 1.3  2005/03/31 00:06:04  lwang
 * added feature for the tool to convert the BIN only
 *
 * Revision 1.2  2005/03/23 23:59:18  lwang
 * added feature to update binary only
 *
 * Revision 1.1  2004/12/31 20:52:28  kwalton
 * Add AMSS 6275 Rel 1.0 ThinUI
 * Port Sierra code from 6250
 *
 * Revision 1.1  2004/11/23 23:01:47  lwang
 * Import source code from EM86XX project (branched @ EM86XX_FD_16.00.48)
 *
 * Revision 1.3  2001/03/20 19:13:39  jkwok
 * Application header converter is CWE compatible; modified from Rosetta version
 *
 * Revision 1.9  2001/02/23 22:37:01  seven
 * Corrected a bug when updating ELF file
 *
 */
