--- ./testcases/kernel/syscalls/creat/creat08.c.orig	2019-01-15 10:51:49.333943601 +0100
+++ ./testcases/kernel/syscalls/creat/creat08.c	2019-01-15 15:52:52.821422485 +0100
@@ -51,6 +51,7 @@
 #include <errno.h>
 #include <grp.h>
 #include <pwd.h>
+#include <sys/utsname.h>
 #include "test.h"
 #include "safe_macros.h"
 
@@ -85,6 +86,8 @@
 	gid_t group1_gid, group2_gid, mygid;
 	uid_t save_myuid, user1_uid;
 	pid_t mypid;
+	struct utsname un;
+	unsigned M, m, r;
 
 	int fd;
 	int lc;
@@ -93,6 +96,12 @@
 
 	setup();
 
+	uname(&un);
+	if (3 != sscanf(un.release, "%u.%u.%u", &M, &m, &r))
+		tst_resm(TINFO, "failed to scan uname.release");
+	else
+		tst_resm(TINFO, "Kernel release is %u.%u.%u", M, m, r);
+
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 
 		local_flag = PASSED;
@@ -362,10 +371,28 @@
 
 		/* Verify modes */
 		if (!(buf.st_mode & S_ISGID)) {
-			tst_resm(TFAIL,
-				 "%s: Incorrect modes, setgid bit should be set",
-				 setgid_B);
-			local_flag = FAILED;
+			/*
+			 * With kernel 3.18.116+, the setgid bit is cleared. So
+                         * handle here this specific case
+                         */
+			if (!((3 == M) && (18 == m) && (116 <= r))) {
+				tst_resm(TFAIL,
+				 	"%s: Incorrect modes, setgid bit should be set",
+				 	setgid_B);
+				local_flag = FAILED;
+			}
+		}
+		else {
+			/*
+			 * With kernel 3.18.116+, the setgid bit is cleared. So
+                         * handle here this specific case
+                         */
+			if ((3 == M) && (18 == m) && (116 <= r)) {
+				tst_resm(TFAIL,
+				 	"%s: Incorrect modes, setgid bit should not be set",
+				 	setgid_B);
+				local_flag = FAILED;
+			}
 		}
 		close(fd);
 
--- ./testcases/kernel/syscalls/open/open10.c.orig	2019-01-15 13:36:01.789659366 +0100
+++ ./testcases/kernel/syscalls/open/open10.c	2019-01-15 15:54:27.157419763 +0100
@@ -41,6 +41,7 @@
 #include <errno.h>
 #include <grp.h>
 #include <pwd.h>
+#include <sys/utsname.h>
 #include "test.h"
 
 char *TCID = "open10";
@@ -74,6 +75,8 @@
 	gid_t group1_gid, group2_gid, mygid;
 	uid_t save_myuid, user1_uid;
 	pid_t mypid;
+	struct utsname un;
+	unsigned M, m, r;
 
 	int lc;
 	int fail_count = 0;
@@ -82,6 +85,12 @@
 
 	setup();
 
+	uname(&un);
+	if (3 != sscanf(un.release, "%u.%u.%u", &M, &m, &r))
+		tst_resm(TINFO, "failed to scan uname.release");
+	else
+		tst_resm(TINFO, "Kernel release is %u.%u.%u", M, m, r);
+
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 		local_flag = PASSED;
 
@@ -347,10 +356,28 @@
 
 		/* Verify modes */
 		if (!(buf.st_mode & S_ISGID)) {
-			tst_resm(TFAIL,
-				 "%s: Incorrect modes, setgid bit not set",
-				 setgid_B);
-			local_flag = FAILED;
+			/*
+			 * With kernel 3.18.116+, the setgid bit is cleared. So
+                         * handle here this specific case
+                         */
+			if (!((3 == M) && (18 == m) && (116 <= r))) {
+				tst_resm(TFAIL,
+				 	"%s: Incorrect modes, setgid bit should be set",
+				 	setgid_B);
+				local_flag = FAILED;
+			}
+		}
+		else {
+			/*
+			 * With kernel 3.18.116+, the setgid bit is cleared. So
+                         * handle here this specific case
+                         */
+			if ((3 == M) && (18 == m) && (116 <= r)) {
+				tst_resm(TFAIL,
+				 	"%s: Incorrect modes, setgid bit should not be set",
+				 	setgid_B);
+				local_flag = FAILED;
+			}
 		}
 
 		if (local_flag == PASSED) {
